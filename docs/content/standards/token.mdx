---
title: Closed Loop Token
---

Closed Loop Token allows its creator to limit applications where the token is used, set up custom policies for transfers, spending and conversions. It is defined in the `sui::token` module and is a part of the Sui Framework.

## Background & Use Cases

The standard Coin implementation on Sui is an example of an open-loop system - Coins are free-flowing, "wrappable", and the best real world analogy would be "cash" - hardly regulated and can be used for any purpose.

However, some applications require constraining the scope of the token to a specific purpose. For example, a token that can only be used for a specific service, or it can be used only by an authorized account, or it can be used freely while account is not blocked. A real-world analogy would be a "bank account" - bank accounts are regulated, controlled by the bank and comply with certain rules and policies.

Specific domains that can benefit from a closed-loop token include:

- **Loyalty Points** - A token that can only be used for a specific service, e.g. for an airline - granted to frequent flyers and used to purchase tickets or upgrades.
- **Regulatory-Compliant Tokens** - some jurisdictions require certain checks or restrictions on tokens. For example, a token that can only be used by a verified user, or a single operation with a token can have a limit.
- **In-Game Currency** - similar to "gems" and "diamonds" in mobile games: a token that can only be used in a game and granted to players for their actions or purchased. Tokens of this kind are often not transferrable and minted in predefined amounts to maintain scarcity and game balance.

## Difference with Coin

Unlike Coin, which has `key + store` abilities and thus supports wrapping and public transfers, Token has only the `key` ability and cannot be wrapped, stored as a dynamic field, or freely transferred (unless there's a custom policy for that).

```move
// defined in `sui::coin`
struct Coin<phantom T> has key, store { id: UID, balance: Balance<T> }

// defined in `sui::token`
struct Token<phantom T> has key { id: UID, balance: Balance<T> }
```

Due to this restriction, Token can only be owned by an account and can't be stored in an application (however, it can be "spent" - see "spending" section).

## Create / Mint & Burn

Token reuses the `TreasuryCap` defined in the `sui::coin` module and therefore has the same initialization process.

```move
module example::my_token {
    use sui::tx_context::{Self, TxContext};
    use sui::transfer;
    use sui::coin;

    /// The One Time Witness and the type of the Coin / Token
    struct MY_TOKEN has drop {}

    // Create the `TreasuryCap` just like you would for a Coin
    fun init(otw: MY_TOKEN, ctx: &mut TxContext) {
        let (treasury_cap, coin_metadata) = coin::create_currency(
            otw, b"MYT", b"My Token", "My Custom Token", std::option::none(), ctx
        );

        transfer::public_freeze_object(coin_metadata);
        transfer::public_transfer(treasury_cap, tx_context::sender(ctx));
    }
}
```

Minting and burning methods are provided by the `sui::token` module; just like with `Coin`, they require the `TreasuryCap` to be passed as an argument.

```move
// module: sui::token

public fun mint<T>(cap: &mut TreasuryCap<T>, amount: u64, ctx: &mut TxContext): Token<T>;

public fun burn<T>(cap: &mut TreasuryCap<T>, token: Token<T>);
```

## Public Actions

Token has a set of public and protected actions which can be used to manage the token. Public actions are available to everyone and don't require any authorization. They have similar APIs to Coin's but operate on the `Token` type:

- `token::keep` - send a Token to the transaction sender
- `token::join` - join two Tokens
- `token::split` - split a Token into two, specify the amount to split
- `token::zero` - create an empty (zero balance) Token
- `token::destroy_zero` - destroy a Token with zero balance

> See Appendix A for Coin and Token methods comparison.

## Protected Actions & Action Request

Some actions are protected and disabled by default. Token creator can enable them by either creating a "TokenPolicy" and "allow"-ing them there or setting up Rules for the action. In standard implementation Token has 4 protected functions:

{/* TODO: revisit ^ above */}

- `token::transfer` - transfer a Token to a recipient
- `token::from_coin` - convert a Coin into a Token
- `token::to_coin` - convert a Token into a Coin
- `token::spend` - spend a Token (see "spending" section)

Protected actions are functions that issue an `ActionRequest` - a special hot-potato struct which must be "confirmed" for the transaction to succeed. ActionRequest is defined in the `sui::token` module and contains the following fields:

- `name` - name of the performed action, standard ones are "transfer", "spend", "to_coin" and "from_coin"; and it is possible to create custom ones.
- `amount` - the amount of the token that is being transferred, spent, converted, etc.
- `sender` - the account that initiated the action
- `recipient` - the account that receives the token in "transfer" action (can be used for custom actions)
- `spent_balance` - the balance of a spent Token in the "spend" action (can be utilized in custom actions)

These fields can be used by so-called "Rules" to determine whether the action should be allowed or not. Rules are custom modules which implement restriction logic. See "Rules" section for more details.

An example of a function creating an `ActionRequest`:
```move
// module: sui::token

public fun transfer<T>(t: Token<T>, recipient: address, ctx: &mut TxContext): ActionRequest<T>;
```

## Request Confirmation

There are 2 main ways to confirm an `ActionRequest`:

1. With a `TreasuryCap` - token creator (or an application storing the TreasuryCap) can confirm any request by calling `token::confirm_with_treasury_cap` function. This method is useful for applications that store the TreasuryCap and implement custom logic; it also allows the Token creator to `mint` and `transfer` tokens bypassing the restrictions.
2. With a `TokenPolicy` - token creator can create and share a `TokenPolicy` and set up allowed actions and requirements for each action. This way any application or a wallet would know which actions can be considered "public" and would be able to perform them.

An example of a transaction implemented in TypeScript with sui.js, confirming an `ActionRequest` with a TreasuryCap:

```js
let tx = new TransactionBlock();
let tokenType = '0x....::my_token::MY_TOKEN';
let treasuryCapArg = tx.object('0x....');

// mint a 10 tokens using the TreasuryCap
let token = tx.moveCall({
    target: '0x2::token::mint',
    arguments: [ treasuryCapArg, tx.pure.u64(10) ],
    typeArguments: [ tokenType ],
});

// transfer the token to a recipient; receive an `ActionRequest`
let request = tx.moveCall({
    target: '0x2::token::transfer',
    arguments: [ token, tx.pure.address('0x...') ],
    typeArguments: [ tokenType ],
});

// confirm the request with the TreasuryCap
tx.moveCall({
    target: '0x2::token::confirm_with_treasury_cap',
    arguments: [ treasuryCapArg, request ],
    typeArguments: [ tokenType ],
});

// submit the transaction
// ...
```

## TokenPolicy & Rules

...TBD



## Appendix A: Coin / Token API comparison

| Function                    | Coin | Token       | Note                                                                             |
|-----------------------------|------|-------------|----------------------------------------------------------------------------------|
| mint                        | +    | +           | Requires TreasuryCap                                                             |
| burn                        | +    | +           | Requires TreasuryCap                                                             |
| join                        | +    | +           | Public                                                                           |
| split                       | +    | +           | Public                                                                           |
| zero                        | +    | +           | Public                                                                           |
| destroy_zero                | +    | +           | Public                                                                           |
| keep                        | -    | +           | Send Token to sender, not required for Coin due to lack of transfer restrictions |
| transfer                    | +    | \[protected] | Coin is transferable by default, Token requires authorization                    |
| to_balance / to_coin        | +    | \[protected] | Token can be converted "to_coin", requires authorization                         |
| from_balance / from_balance | +    | \[protected] | Token can be created "from_coin", requires authorization                         |
| spend                       | -    | \[protected] | Token can be "spent", requires authorization (see "spending")                    |
